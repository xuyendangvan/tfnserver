/*
 * Demo App
 *
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * API version: 1.0.0
 * Contact: apiteam@swagger.io
 * Generated by: Swagger Codegen (https://github.com/swagger-api/swagger-codegen.git)
 */

package swagger

import (
	"context"
	"encoding/json"
	"fmt"
	"log"
	"net/http"
	"strconv"
	db "tfnserver/db"
	messaging "tfnserver/firebase_messaging"
	model "tfnserver/model"
	"time"

	"github.com/gorilla/mux"
)

func AddStudent(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	w.Header().Set("Connection", "close")
	r.Header.Set("Connection", "close")
	defer r.Body.Close()
	decoder := json.NewDecoder(r.Body)
	var student model.Student
	err := decoder.Decode(&student)
	log.Println(student)
	if err != nil {
		log.Println("sss", err)
		w.WriteHeader(http.StatusUnprocessableEntity)
		return
	}
	e := createRecordStudents(student)
	if e != nil {
		log.Println(e)
		w.WriteHeader(http.StatusBadRequest)
		return
	}
	w.WriteHeader(http.StatusOK)
}

func createRecordStudents(students model.Student) (err error) {
	database := db.DBConn()
	defer database.Close()
	tx, err := db.SQLBegin(database)
	if err != nil {
		return err
	}
	ClassID := students.ClassID
	ParentID := students.ParentID
	Name := students.Name
	//Birthday := students.Birthday ? time.Now()
	DateCreate := time.Now()
	DateUpdate := time.Now()

	insForm, err := db.SQLExec(tx, "INSERT INTO Student(parent_id, class_id, name, face_photo, date_create, date_update, update_count) VALUES(?,?,?,?,?,?,?)")
	if err != nil {
		return err
	}
	id, err := insForm.Exec(ParentID, ClassID, Name, "", DateCreate, DateUpdate, 0)
	if err != nil {
		log.Println(err)
		tx.Rollback()
		return err
	}

	// get last inserted id
	lid, err := id.LastInsertId()

	// insert student status
	insForm, err = db.SQLExec(tx, "INSERT INTO Student_status(student_id, status) VALUES(?,?)")
	if err != nil {
		return err
	}
	_, err = insForm.Exec(lid, 2)
	if err != nil {
		log.Println(err)
		tx.Rollback()
		return err
	}

	log.Println("id student status is", id)
	tx.Commit()
	return nil
}

func DeleteStudentByID(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	w.Header().Set("Connection", "close")
	r.Header.Set("Connection", "close")
	defer r.Body.Close()
	ID := mux.Vars(r)["id"]
	log.Printf(ID)
	e := deleteRecordStudent(ID)
	if e != nil {
		w.WriteHeader(http.StatusBadRequest)
		return
	}
	w.WriteHeader(http.StatusOK)
}

func deleteRecordStudent(ID string) (err error) {
	database := db.DBConn()
	defer database.Close()
	tx, err := db.SQLBegin(database)
	if err != nil {
		return err
	}
	insForm, err := database.Prepare("DELETE FROM Student WHERE id= ?")
	if _, err := insForm.Exec(ID); err != nil {
		tx.Rollback()
		return err
	}
	tx.Commit()
	return nil
}

func FindStudentByID(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	w.Header().Set("Connection", "close")
	r.Header.Set("Connection", "close")
	defer r.Body.Close()
	ID := mux.Vars(r)["id"]
	log.Printf(ID)
	jsonResponse := getDataStudentFromDB(ID)
	if jsonResponse == nil {
		w.WriteHeader(http.StatusNoContent)
		return
	}
	w.Write(jsonResponse)
	w.WriteHeader(http.StatusOK)
}

func getDataStudentFromDB(id string) []byte {
	database := db.DBConn()
	defer database.Close()
	var (
		user model.Student
	)
	rows, err := database.Query("SELECT * FROM Student WHERE id= ?", id)
	if err != nil {
		fmt.Println(err)
		return nil
	}
	for rows.Next() {
		var date, datecreate time.Time
		var count int
		var face_photo string
		rows.Scan(&user.Id, &user.ParentID, &user.ClassID, &user.Name, &user.Birthday, &face_photo, &datecreate, &date, &count)
	}
	defer rows.Close()
	jsonResponse, jsonError := json.Marshal(user)
	if jsonError != nil {
		fmt.Println(jsonError)
		return nil
	}
	return jsonResponse
}

func FindStudentListByIndex(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	w.Header().Set("Connection", "close")
	r.Header.Set("Connection", "close")
	defer r.Body.Close()
	startIndexs, value := r.URL.Query()["startIndex"]

	if !value || len(startIndexs[0]) < 1 {
		log.Println("Url Param 'key' is missing")
		w.WriteHeader(http.StatusNotFound)
		return
	}
	startIndex := startIndexs[0]

	offsets, value := r.URL.Query()["offset"]

	if !value || len(offsets[0]) < 1 {
		log.Println("Url Param 'key' is missing")
		w.WriteHeader(http.StatusNotFound)
		return
	}
	offset := offsets[0]

	jsonResponse := getDataStudentFromDBWithIndex(startIndex, offset)
	if jsonResponse == nil {
		w.WriteHeader(http.StatusNoContent)
		return
	}
	w.Write(jsonResponse)
	w.WriteHeader(http.StatusOK)
}

func getDataStudentFromDBWithIndex(startIndex string, offset string) []byte {
	database := db.DBConn()
	defer database.Close()
	var (
		user    model.Student
		records []model.Student
	)
	limitValue, err := strconv.Atoi(offset)
	startValue, err := strconv.Atoi(startIndex)
	rows, err := database.Query("SELECT * FROM Student limit ? offset ?", limitValue, startValue)
	if err != nil {
		fmt.Println(err)
		return nil
	}
	for rows.Next() {
		var date, datecreate time.Time
		var count int
		var face_photo string
		rows.Scan(&user.Id, &user.ParentID, &user.ClassID, &user.Name, &user.Birthday, &face_photo, &datecreate, &date, &count)
		records = append(records, user)
	}
	defer rows.Close()
	if records == nil {
		return nil
	}
	jsonResponse, jsonError := json.Marshal(records)
	if jsonError != nil {
		fmt.Println(jsonError)
		return nil
	}
	return jsonResponse
}

func UpdateStudent(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	w.Header().Set("Connection", "close")
	r.Header.Set("Connection", "close")
	defer r.Body.Close()
	ID := mux.Vars(r)["id"]
	log.Printf(ID)
	decoder := json.NewDecoder(r.Body)
	var t model.Student
	err := decoder.Decode(&t)
	if err != nil {
		w.WriteHeader(http.StatusUnprocessableEntity)
		return
	}
	log.Println(t)
	e := updateRecordStudent(ID, t)
	if e != nil {
		log.Printf(e.Error())
		w.WriteHeader(http.StatusBadRequest)
		return
	}
	w.WriteHeader(http.StatusOK)
}

func updateRecordStudent(ID string, t model.Student) (err error) {
	database := db.DBConn()
	defer database.Close()
	tx, err := db.SQLBegin(database)
	if err != nil {
		log.Println(err)
		return err
	}
	sid, err := strconv.Atoi(ID)
	ParentID := t.ParentID
	ClassID := t.ClassID
	Name := t.Name
	Birthday := t.Birthday
	updateDate := time.Now()
	insForm, err := db.SQLExec(tx, "Update Student Set parent_id= ?,class_id= ?, name= ? ,birthday= ?,date_update= ?, update_count = update_count + 1 where id= ?")
	if err != nil {
		log.Println(err)
		return err
	}
	if _, err := insForm.Exec(ParentID, ClassID, Name, Birthday, updateDate, sid); err != nil {
		tx.Rollback()
		log.Println(err)
		return err
	}
	tx.Commit()
	return nil
}

// UpdateStudentStatus : update when teacher do a roll call
func UpdateStudentStatus(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	w.Header().Set("Connection", "close")
	r.Header.Set("Connection", "close")
	defer r.Body.Close()

	// get params
	ids, _ := r.URL.Query()["id"]

	ID := ids[0]

	status, _ := r.URL.Query()["status"]
	Status := status[0]

	log.Println(ID)
	e := updateRecordStudentStatus(ID, Status)
	if e != nil {
		log.Printf(e.Error())
		w.WriteHeader(http.StatusBadRequest)
		return
	}
	w.WriteHeader(http.StatusOK)
}

func updateRecordStudentStatus(id string, status string) (err error) {
	database := db.DBConn()
	defer database.Close()
	tx, err := db.SQLBegin(database)
	if err != nil {
		log.Println(err)
		return err
	}
	sid, _ := strconv.Atoi(id)

	insForm, err := db.SQLExec(tx, "Update Student_status Set status = ? where student_id = ?")
	if err != nil {
		log.Println(err)
		return err
	}
	if _, err := insForm.Exec(status, sid); err != nil {
		tx.Rollback()
		log.Println(err)
		return err
	}
	tx.Commit()

	// init the fcm app
	app := messaging.InitializeAppWithServiceAccount()
	ctxBG := context.Background()
	client, _ := app.Messaging(ctxBG)

	// select the token for parent device
	rows, err := database.Query("SELECT d.token FROM device_token d inner join student s on s.id = ? and d.parent_id = s.parent_id;", sid)
	if err != nil {
		log.Println(err)
		return err
	}

	var (
		token  string
		tokens []string
	)
	for rows.Next() {
		rows.Scan(&token)
		tokens = append(tokens, token)
	}
	defer rows.Close()
	log.Println(ctxBG, client, tokens)
	messaging.SendMulti(ctxBG, client, tokens)
	return nil
}

func FindStudentActivityByID(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	w.Header().Set("Connection", "close")
	r.Header.Set("Connection", "close")
	defer r.Body.Close()
	ID := mux.Vars(r)["id"]
	log.Printf(ID)
	jsonResponse := getDataStudentActivityFromDB(ID)
	if jsonResponse == nil {
		w.WriteHeader(http.StatusNoContent)
		return
	}
	w.Write(jsonResponse)
	w.WriteHeader(http.StatusOK)
}

func getDataStudentActivityFromDB(id string) []byte {
	database := db.DBConn()
	defer database.Close()
	var (
		data    model.Activity
		records []model.Activity
	)
	rows, err := database.Query("SELECT a.id,a.type,a.date_occur,a.date_expire,a.poster_id,a.title,a.content,a.photo1,a.caption1,a.photo2,a.caption2,a.photo3,a.caption3,a.photo4,a.caption4,a.photo5,a.caption5,a.date_create,a.date_update,a.update_count FROM Activity a where a.type = 2 or a.class_id = (select class_id from Student s where s.id = ?)", id)
	if err != nil {
		fmt.Println(err)
		return nil
	}
	for rows.Next() {
		var date, datecreate time.Time
		var count int
		rows.Scan(&data.Id, &data.Type_, &data.DateOccur, &data.DateExpired, &data.TeacherID, &data.Title, &data.Content, &data.Photo1, &data.Caption1, &data.Photo2, &data.Caption2, &data.Photo3, &data.Caption3, &data.Photo4, &data.Caption4, &data.Photo5, &data.Caption5, &datecreate, &date, &count)
		records = append(records, data)
	}
	defer rows.Close()
	if records == nil {
		return nil
	}
	jsonResponse, jsonError := json.Marshal(records)
	if jsonError != nil {
		fmt.Println(jsonError)
		return nil
	}
	return jsonResponse
}

func FindStudentNoticeByID(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	w.Header().Set("Connection", "close")
	r.Header.Set("Connection", "close")
	defer r.Body.Close()
	ID := mux.Vars(r)["id"]
	log.Printf(ID)
	jsonResponse := getDataStudentNoticeFromDB(ID)
	if jsonResponse == nil {
		w.WriteHeader(http.StatusNoContent)
		return
	}
	w.Write(jsonResponse)
	w.WriteHeader(http.StatusOK)
}

func getDataStudentNoticeFromDB(id string) []byte {
	database := db.DBConn()
	defer database.Close()
	var (
		data    model.Notice
		records []model.Notice
	)
	rows, err := database.Query("SELECT n.id,n.severity,n.type,n.class_id,n.parent_id,n.date_occur,n.date_expire,n.teacher_id,n.title,n.content,n.confirm_message,n.date_create,n.date_update,n.update_count FROM Notice n where n.student_id = ? or (n.student_id = 1000 AND n.class_id = (select s.class_id from student s where s.id = ?))", id, id)
	if err != nil {
		fmt.Println(err)
		return nil
	}
	for rows.Next() {
		data.Content = nil
		var date, datecreate time.Time
		var severity string
		var count int
		var content string
		rows.Scan(&data.Id, &severity, &data.Type_, &data.StudentID, &data.ParentID, &data.DateOccur, &data.DateExpired, &data.TeacherID, &data.Title, &content, &data.ConfirmMessage, &datecreate, &date, &count)

		fmt.Println(content)

		data.Content = append(data.Content, content)
		records = append(records, data)
	}
	defer rows.Close()
	if records == nil {
		return nil
	}
	jsonResponse, jsonError := json.Marshal(records)
	if jsonError != nil {
		fmt.Println(jsonError)
		return nil
	}
	return jsonResponse
}

func FindStudentTuitionFeeyByID(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	w.Header().Set("Connection", "close")
	r.Header.Set("Connection", "close")
	defer r.Body.Close()
	sids, value := r.URL.Query()["sid"]

	if !value || len(sids[0]) < 1 {
		log.Println("Url Param 'key' is missing")
		w.WriteHeader(http.StatusNotFound)
		return
	}
	sid := sids[0]

	qids, value := r.URL.Query()["qid"]

	if !value || len(qids[0]) < 1 {
		log.Println("Url Param 'key' is missing")
		w.WriteHeader(http.StatusNotFound)
		return
	}
	qid := qids[0]
	jsonResponse := getStudentTuitionFeeFromDB(sid, qid)
	if jsonResponse == nil {
		w.WriteHeader(http.StatusNoContent)
		return
	}
	w.Write(jsonResponse)
	w.WriteHeader(http.StatusOK)
}

func getStudentTuitionFeeFromDB(id string, qid string) []byte {
	database := db.DBConn()
	defer database.Close()
	var (
		data model.TuitionFee
	)
	idValue, err := strconv.Atoi(id)
	sidValue, err := strconv.Atoi(qid)
	rows, err := database.Query("SELECT * FROM Tution_fee where student_id = ? and quater_id = ?", idValue, sidValue)
	if err != nil {
		fmt.Println(err)
		return nil
	}
	for rows.Next() {
		var date time.Time
		var count int
		rows.Scan(&data.Id, &data.StudentID, &data.Quater, &data.Tuition, &data.Other, &data.Bus, &data.Food, &data.Refund, &data.Total, &data.Paid, &data.DateCreated, &date, &count)
	}
	defer rows.Close()
	jsonResponse, jsonError := json.Marshal(data)
	if jsonError != nil {
		fmt.Println(jsonError)
		return nil
	}
	return jsonResponse
}
